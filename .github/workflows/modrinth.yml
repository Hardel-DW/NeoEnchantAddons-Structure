name: Publish to Modrinth (datapack + mod, changeset)

on:
  push:
    branches: [ main ]
    paths:
      - ".changeset/**/*.md"
      - "deploy.yml"

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    env:
      MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip zip
          npm i -g gray-matter yaml
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      # 1) Lire deploy.yml & .changeset/*.md, agréger et calculer la nouvelle version
      - name: Parse deploy.yml & changesets
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          DEPLOY_FILE="deploy.yml"
          test -f "$DEPLOY_FILE"
          test -d ".changeset"

          # YAML -> JSON
          DEPLOY_JSON="$(node -e 'const fs=require("fs");const yaml=require("yaml");
            const o=yaml.parse(fs.readFileSync("deploy.yml","utf8"));console.log(JSON.stringify(o||{}))')"
          echo "$DEPLOY_JSON" | jq . > deploy.json

          # Agréger tous les .md
          node >/tmp/agg.json <<'NODE'
          const fs=require("fs");
          const path=require("path");
          const matter=require("gray-matter");
          const dir=".changeset";
          const files=(fs.existsSync(dir)?fs.readdirSync(dir):[]).filter(f=>f.endsWith(".md")).map(f=>path.join(dir,f));
          if(!files.length){ console.error("Aucun .md dans .changeset/"); process.exit(1); }
          const bumpRank=v=>v==="major"?3:v==="minor"?2:v==="patch"?1:0;
          let bump="patch", br=1, version_type=null;
          const gvs=new Set(), loaders=new Set();
          let changelog="";
          for(const f of files){
            const r=matter(fs.readFileSync(f,"utf8"));
            const fm=r.data||{};
            if(bumpRank(fm.bump)>br){ bump=fm.bump; br=bumpRank(fm.bump); }
            if(!version_type && fm.type) version_type=fm.type;
            (fm.game_versions||[]).forEach(v=>gvs.add(String(v)));
            (fm.loaders||[]).forEach(l=>loaders.add(String(l)));
            const body=(r.content||"").trim();
            if(body) changelog += `### ${f}\n${body}\n\n`;
          }
          const out={ bump, version_type, game_versions:[...gvs], loaders:[...loaders], changelog:changelog.trim() };
          console.log(JSON.stringify(out));
NODE

          cat /tmp/agg.json | jq . > changes.json

          # Version bump
          BUMP="$(jq -r '.bump // "patch"' changes.json)"
          MAJOR=$(jq -r '.version.major' deploy.json)
          MINOR=$(jq -r '.version.minor' deploy.json)
          PATCH=$(jq -r '.version.patch' deploy.json)
          case "$BUMP" in
            major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR+1)); PATCH=0 ;;
            *)     PATCH=$((PATCH+1)) ;;
          esac
          VERSION="${MAJOR}.${MINOR}.${PATCH}"

          # version_type
          VERSION_TYPE="$(jq -r '.version_type // empty' changes.json)"
          if [ -z "$VERSION_TYPE" ] || [ "$VERSION_TYPE" = "null" ]; then
            VERSION_TYPE="$(jq -r '.modrinth.version_type // "release"' deploy.json)"
          fi

          # loaders pour la version MOD = union(changeset, deploy)
          LOADERS_MOD="$(jq -c '([.loaders[]] // []) as $a | input | ([.modrinth.loaders[]] // []) as $b | ( ($a+$b)|unique )' \
            changes.json deploy.json)"

          # game_versions (obligatoire)
          GAME_VERSIONS="$(jq -c '.game_versions // []' changes.json)"

          # datapack loaders (fixés à ["datapack"])
          LOADERS_DP='["datapack"]'

          PROJECT_ID="$(jq -r '.modrinth.project_id' deploy.json)"
          PACKAGE_AS_MOD="$(jq -r '.modrinth.package_as_mod // false' deploy.json)"

          # Métadonnées MOD (utiliser TOUS les champs fournis)
          MOD_ID="$(jq -r '.mod.id' deploy.json)"
          MOD_NAME="$(jq -r '.mod.name' deploy.json)"
          MOD_AUTHORS="$(jq -c '.mod.authors // []' deploy.json)"
          MOD_HOMEPAGE="$(jq -r '.mod.homepage // empty' deploy.json)"
          MOD_ISSUES="$(jq -r '.mod.issues // empty' deploy.json)"
          MOD_SOURCES="$(jq -r '.mod.sources // empty' deploy.json)"

          # Changelog (concat)
          CHANGELOG="$(jq -r '.changelog' changes.json)"
          printf '%s\n' "$CHANGELOG" > CHANGELOG_MODRINTH.md

          {
            echo "version=$VERSION"
            echo "major=$MAJOR"
            echo "minor=$MINOR"
            echo "patch=$PATCH"
            echo "version_type=$VERSION_TYPE"
            echo "project_id=$PROJECT_ID"
            echo "loaders_mod=$LOADERS_MOD"
            echo "loaders_dp=$LOADERS_DP"
            echo "game_versions=$GAME_VERSIONS"
            echo "package_as_mod=$PACKAGE_AS_MOD"
            echo "deploy_file=$DEPLOY_FILE"
            echo "mod_id=$MOD_ID"
            echo "mod_name=$MOD_NAME"
            echo "mod_authors=$MOD_AUTHORS"
            echo "mod_homepage=$MOD_HOMEPAGE"
            echo "mod_issues=$MOD_ISSUES"
            echo "mod_sources=$MOD_SOURCES"
          } >> "$GITHUB_OUTPUT"

      # 2) Créer le ZIP datapack avec exclusions
      - name: Build datapack ZIP
        id: datapack
        shell: bash
        run: |
          set -euo pipefail
          ART="datapack-${{ steps.meta.outputs.version }}.zip"

          # Prépare le fichier d'exclusions depuis deploy.yml: build.exclude
          jq -r '.build.exclude[]?' deploy.json > .exclude || true
          # Fallback safe
          echo ".git" >> .exclude
          echo ".github" >> .exclude
          # Construire la liste -x pour zip
          EXC_OPTS=()
          while IFS= read -r p; do
            [ -z "$p" ] && continue
            EXC_OPTS+=( "-x" "$p/*" )
            # aussi pattern simple si c'est un fichier
            EXC_OPTS+=( "-x" "$p" )
          done < .exclude

          zip -r "$ART" . "${EXC_OPTS[@]}"
          echo "file=$ART" >> "$GITHUB_OUTPUT"

      # 3) Créer le JAR mod (si package_as_mod)
      - name: Build MOD JAR
        if: ${{ steps.meta.outputs.package_as_mod == 'true' }}
        id: modpkg
        shell: bash
        run: |
          set -euo pipefail
          WORK="packmod"
          rm -rf "$WORK" && mkdir -p "$WORK"
          unzip -q "${{ steps.datapack.outputs.file }}" -d "$WORK"

          MODID='${{ steps.meta.outputs.mod_id }}'
          NAME='${{ steps.meta.outputs.mod_name }}'
          VERSION='${{ steps.meta.outputs.version }}'
          AUTHORS='${{ steps.meta.outputs.mod_authors }}'
          HOMEPAGE='${{ steps.meta.outputs.mod_homepage }}'
          ISSUES='${{ steps.meta.outputs.mod_issues }}'
          SOURCES='${{ steps.meta.outputs.mod_sources }}'

          # authors en JSON -> array de strings
          echo "$AUTHORS" | jq -r '.[]?' > /tmp/auth.txt || true

          # fabric.mod.json
          if echo '${{ steps.meta.outputs.loaders_mod }}' | jq -r '.[]' | grep -q '^fabric$'; then
            jq -n \
              --arg id "$MODID" \
              --arg name "$NAME" \
              --arg version "$VERSION" \
              --arg homepage "$HOMEPAGE" \
              --arg issues "$ISSUES" \
              --arg sources "$SOURCES" \
              --argjson authors "${AUTHORS:-[]}" \
              '{
                schemaVersion:1,
                id:$id,
                version:$version,
                name:$name,
                description:"Packaged as mod",
                authors:$authors,
                contact:{
                  homepage: ($homepage|select(.!="")),
                  issues:   ($issues|select(.!="")),
                  sources:  ($sources|select(.!=""))
                },
                license:"MIT",
                environment:"*",
                depends:{}
              }' > "$WORK/fabric.mod.json"
          fi

          # quilt.mod.json
          if echo '${{ steps.meta.outputs.loaders_mod }}' | jq -r '.[]' | grep -q '^quilt$'; then
            jq -n \
              --arg id "$MODID" \
              --arg name "$NAME" \
              --arg version "$VERSION" \
              --arg homepage "$HOMEPAGE" \
              --arg issues "$ISSUES" \
              --arg sources "$SOURCES" \
              --argjson authors "${AUTHORS:-[]}" \
              '{
                schema_version:1,
                quilt_loader:{
                  group:$id,
                  id:$id,
                  version:$version,
                  metadata:{
                    name:$name,
                    description:"Packaged as mod",
                    contributors: ( $authors | map({name:.}) ),
                    contact:{
                      homepage: ($homepage|select(.!="")),
                      issues:   ($issues|select(.!="")),
                      sources:  ($sources|select(.!=""))
                    },
                    license:"MIT"
                  }
                }
              }' > "$WORK/quilt.mod.json"
          fi

          # Forge mods.toml
          if echo '${{ steps.meta.outputs.loaders_mod }}' | jq -r '.[]' | grep -q '^forge$'; then
            mkdir -p "$WORK/META-INF"
            cat > "$WORK/META-INF/mods.toml" <<EOF
modLoader="javafml"
loaderVersion="[0,)"
license="MIT"
[[mods]]
modId="${MODID}"
version="${VERSION}"
displayName="${NAME}"
description="Packaged as mod"
EOF
          fi

          # NeoForge neoforge.mods.toml
          if echo '${{ steps.meta.outputs.loaders_mod }}' | jq -r '.[]' | grep -q '^neoforge$'; then
            mkdir -p "$WORK/META-INF"
            cat > "$WORK/META-INF/neoforge.mods.toml" <<EOF
modLoader="javafml"
loaderVersion="[0,)"
license="MIT"
[[mods]]
modId="${MODID}"
version="${VERSION}"
displayName="${NAME}"
description="Packaged as mod"
EOF
          fi

          JAR="mod-${{ steps.meta.outputs.version }}.jar"
          (cd "$WORK" && zip -qr "../$JAR" .)
          echo "file=$JAR" >> "$GITHUB_OUTPUT"

      # 4) Publier la VERSION DATAPACK (indépendante)
      - name: Publish Datapack to Modrinth
        id: publish_dp
        env:
          PROJECT_ID: ${{ steps.meta.outputs.project_id }}
          VERSION: ${{ steps.meta.outputs.version }}
          VERSION_TYPE: ${{ steps.meta.outputs.version_type }}
          GAME_VERSIONS: ${{ steps.meta.outputs.game_versions }}
          LOADERS: ${{ steps.meta.outputs.loaders_dp }}
          FILE: ${{ steps.datapack.outputs.file }}
        run: |
          DATA_JSON=$(jq -n \
            --arg project_id "$PROJECT_ID" \
            --arg name "v${VERSION} (datapack)" \
            --arg version_number "$VERSION" \
            --arg version_type "$VERSION_TYPE" \
            --arg changelog "$(cat CHANGELOG_MODRINTH.md)" \
            --argjson game_versions "$GAME_VERSIONS" \
            --argjson loaders "$LOADERS" \
            '{
              project_id:$project_id,
              name:$name,
              version_number:$version_number,
              changelog:$changelog,
              version_type:$version_type,
              game_versions:$game_versions,
              loaders:$loaders,
              featured:false,
              file_parts:["file"],
              primary_file:"file"
            }')
          echo "$DATA_JSON" | jq .
          code=$(curl -sS -o dp_response.json -w "%{http_code}" \
            -X POST "https://api.modrinth.com/v2/version" \
            -H "Authorization: ${MODRINTH_TOKEN}" \
            -H "User-Agent: $GITHUB_REPOSITORY CI" \
            -F "data=${DATA_JSON};type=application/json" \
            -F "file=@${FILE};type=application/zip;filename=$(basename "${FILE}")")
          echo "HTTP $code"
          cat dp_response.json | jq . || cat dp_response.json
          test "$code" -ge 200 -a "$code" -lt 300

      # 5) Publier la VERSION MOD (indépendante, si package_as_mod)
      - name: Publish Mod to Modrinth
        if: ${{ steps.meta.outputs.package_as_mod == 'true' }}
        id: publish_mod
        env:
          PROJECT_ID: ${{ steps.meta.outputs.project_id }}
          VERSION: ${{ steps.meta.outputs.version }}
          VERSION_TYPE: ${{ steps.meta.outputs.version_type }}
          GAME_VERSIONS: ${{ steps.meta.outputs.game_versions }}
          LOADERS: ${{ steps.meta.outputs.loaders_mod }}
          FILE: ${{ steps.modpkg.outputs.file }}
        run: |
          DATA_JSON=$(jq -n \
            --arg project_id "$PROJECT_ID" \
            --arg name "v${VERSION} (mod)" \
            --arg version_number "$VERSION" \
            --arg version_type "$VERSION_TYPE" \
            --arg changelog "$(cat CHANGELOG_MODRINTH.md)" \
            --argjson game_versions "$GAME_VERSIONS" \
            --argjson loaders "$LOADERS" \
            '{
              project_id:$project_id,
              name:$name,
              version_number:$version_number,
              changelog:$changelog,
              version_type:$version_type,
              game_versions:$game_versions,
              loaders:$loaders,
              featured:false,
              file_parts:["file"],
              primary_file:"file"
            }')
          echo "$DATA_JSON" | jq .
          code=$(curl -sS -o mod_response.json -w "%{http_code}" \
            -X POST "https://api.modrinth.com/v2/version" \
            -H "Authorization: ${MODRINTH_TOKEN}" \
            -H "User-Agent: $GITHUB_REPOSITORY CI" \
            -F "data=${DATA_JSON};type=application/json" \
            -F "file=@${FILE};type=application/java-archive;filename=$(basename "${FILE}")")
          echo "HTTP $code"
          cat mod_response.json | jq . || cat mod_response.json
          test "$code" -ge 200 -a "$code" -lt 300

      # 6) MAJ deploy.yml + suppression .changeset + push
      - name: Commit bump & cleanup
        if: ${{ success() }}
        run: |
          yq -i ".version.major=${{ steps.meta.outputs.major }} | .version.minor=${{ steps.meta.outputs.minor }} | .version.patch=${{ steps.meta.outputs.patch }}" deploy.yml
          rm -rf .changeset
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add deploy.yml
          git add -A
          git commit -m "chore(release): v${{ steps.meta.outputs.version }} [skip ci]" || echo "Rien à committer"
          git push
