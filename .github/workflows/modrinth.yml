name: Deploy

on:
  push:
    paths:
      - '.changeset/*.md'

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Detect changeset
        id: changeset
        run: |
          CHANGESET_FILE=$(find .changeset -name "*.md" -type f | head -n 1)
          if [ -z "$CHANGESET_FILE" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "found=true" >> $GITHUB_OUTPUT
          echo "file=$CHANGESET_FILE" >> $GITHUB_OUTPUT

      - name: Parse changeset
        id: parse
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import re, json, os, yaml
          
          with open("${{ steps.changeset.outputs.file }}", 'r') as f:
              content = f.read()
          
          match = re.match(r'^---\n(.*?)\n---\n(.*)$', content, re.DOTALL)
          if not match:
              exit(1)
          
          frontmatter = yaml.safe_load(match.group(1))
          changelog = match.group(2).strip()
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"game_versions={json.dumps(frontmatter.get('game_versions', []))}\n")
              f.write(f"loaders={json.dumps(frontmatter.get('loaders', None)) if frontmatter.get('loaders') else 'null'}\n")
              f.write(f"version_type={frontmatter.get('version_type', 'release')}\n")
              f.write(f"version_bump={frontmatter.get('version_bump', 'patch')}\n")
              f.write(f"changelog<<EOF\n{changelog}\nEOF\n")
          EOF

      - name: Read config
        id: config
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import yaml, json, os
          
          with open('deploy.yaml', 'r') as f:
              config = yaml.safe_load(f)
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"version_major={config['project']['version']['major']}\n")
              f.write(f"version_minor={config['project']['version']['minor']}\n")
              f.write(f"version_patch={config['project']['version']['patch']}\n")
              f.write(f"modrinth_enabled={str(config['modrinth']['enabled']).lower()}\n")
              f.write(f"modrinth_project_id={config['modrinth']['project_id']}\n")
              f.write(f"curseforge_datapack_enabled={str(config['curseforge']['datapack']['enabled']).lower()}\n")
              f.write(f"curseforge_datapack_id={config['curseforge']['datapack'].get('project_id', '')}\n")
              f.write(f"curseforge_mod_enabled={str(config['curseforge']['mod']['enabled']).lower()}\n")
              f.write(f"curseforge_mod_id={config['curseforge']['mod'].get('project_id', '')}\n")
              f.write(f"curseforge_java_versions={json.dumps(config['curseforge']['mod'].get('java_versions', []))}\n")
              f.write(f"curseforge_environments={json.dumps(config['curseforge']['mod'].get('environments', []))}\n")
              f.write(f"package_as_mod_enabled={str(config['package_as_mod']['enabled']).lower()}\n")
              f.write(f"package_as_mod_loaders={json.dumps(config['package_as_mod']['loaders'])}\n")
              f.write(f"package_as_mod_id={config['package_as_mod']['id']}\n")
              f.write(f"package_as_mod_name={config['package_as_mod'].get('name', '')}\n")
              f.write(f"package_as_mod_authors={json.dumps(config['package_as_mod']['authors'])}\n")
              f.write(f"exclude_patterns={json.dumps(config.get('build', {}).get('exclude', []))}\n")
          EOF

      - name: Increment version
        id: version
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import os
          
          bump = "${{ steps.parse.outputs.version_bump }}"
          major = int("${{ steps.config.outputs.version_major }}")
          minor = int("${{ steps.config.outputs.version_minor }}")
          patch = int("${{ steps.config.outputs.version_patch }}")
          
          if bump == "major":
              major += 1
              minor = 0
              patch = 0
          elif bump == "minor":
              minor += 1
              patch = 0
          elif bump == "patch":
              patch += 1
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"version={major}.{minor}.{patch}\n")
              f.write(f"major={major}\n")
              f.write(f"minor={minor}\n")
              f.write(f"patch={patch}\n")
          EOF

      - name: Resolve loaders
        id: loaders
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import json, os
          
          changeset_loaders = '${{ steps.parse.outputs.loaders }}'
          default_loaders = '${{ steps.config.outputs.package_as_mod_loaders }}'
          
          if changeset_loaders != 'null':
              loaders = json.loads(changeset_loaders)
          else:
              loaders = json.loads(default_loaders)
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"csv={','.join(loaders)}\n")
              f.write(f"json={json.dumps(loaders)}\n")
          EOF

      - name: Format game versions
        id: game_versions
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import json, os
          
          game_versions = json.loads('${{ steps.parse.outputs.game_versions }}')
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"csv={','.join(game_versions)}\n")
              f.write(f"json={json.dumps(game_versions)}\n")
          EOF

      - name: Create directories
        if: steps.changeset.outputs.found == 'true'
        run: mkdir -p dist build-temp

      - name: Copy files
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import shutil, json
          from pathlib import Path
          from fnmatch import fnmatch
          
          exclude = json.loads('${{ steps.config.outputs.exclude_patterns }}') + ['build-temp', 'dist']
          
          def should_exclude(path):
              for pattern in exclude:
                  if fnmatch(str(path.name), pattern) or any(fnmatch(str(p), pattern) for p in path.parents):
                      return True
              return False
          
          src, dst = Path('.'), Path('build-temp')
          for item in src.rglob('*'):
              rel = item.relative_to(src)
              if not should_exclude(rel):
                  dest = dst / rel
                  if item.is_dir():
                      dest.mkdir(parents=True, exist_ok=True)
                  else:
                      dest.parent.mkdir(parents=True, exist_ok=True)
                      shutil.copy2(item, dest)
          EOF

      - name: Build datapack
        if: steps.changeset.outputs.found == 'true'
        run: |
          cd build-temp
          FILENAME="${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.zip"
          zip -r ../dist/${FILENAME} . -x "*.git*" "*.DS_Store"
          cd ..
          [ -f "dist/${FILENAME}" ] || exit 1

      - name: Package as mod
        if: steps.changeset.outputs.found == 'true' && steps.config.outputs.package_as_mod_enabled == 'true'
        run: |
          npm install @voxelio/converter @voxelio/breeze @voxelio/zip
          
          cat > convert.js <<'SCRIPT'
          import { convertDatapack, ModPlatforms } from "@voxelio/converter";
          import { readFile, writeFile } from "fs/promises";
          
          const args = JSON.parse(process.argv[2]);
          const buffer = await readFile(args.input);
          const file = new File([buffer], "datapack.zip");
          const platforms = args.loaders.map(l => ModPlatforms[l.toUpperCase()]).filter(Boolean);
          
          const response = await convertDatapack(file, platforms, {
            id: args.id,
            version: args.version,
            name: args.name,
            description: "",
            authors: args.authors
          });
          
          await writeFile(args.output, Buffer.from(await response.arrayBuffer()));
          SCRIPT
          
          MOD_NAME="${{ steps.config.outputs.package_as_mod_name }}"
          [ -z "$MOD_NAME" ] && MOD_NAME="${{ github.event.repository.name }}"
          
          node convert.js "$(jq -n \
            --arg input "dist/${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.zip" \
            --arg output "dist/${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.jar" \
            --arg id "${{ steps.config.outputs.package_as_mod_id }}" \
            --arg version "${{ steps.version.outputs.version }}" \
            --arg name "$MOD_NAME" \
            --argjson authors '${{ steps.config.outputs.package_as_mod_authors }}' \
            --argjson loaders '${{ steps.loaders.outputs.json }}' \
            '{input:$input, output:$output, id:$id, version:$version, name:$name, authors:$authors, loaders:$loaders}')"

      - name: Fetch CurseForge game versions
        id: cf_versions
        if: steps.changeset.outputs.found == 'true' && (steps.config.outputs.curseforge_datapack_enabled == 'true' || steps.config.outputs.curseforge_mod_enabled == 'true')
        run: |
          curl -sS "https://minecraft.curseforge.com/api/game/versions" \
            -H "X-Api-Token: ${{ secrets.CURSEFORGE_TOKEN }}" > cf_versions.json
          
          python - <<'EOF'
          import json, os
          
          with open('cf_versions.json', 'r') as f:
              versions = json.load(f)
          
          game_versions = json.loads('${{ steps.game_versions.outputs.json }}')
          loaders = json.loads('${{ steps.loaders.outputs.json }}')
          java_versions = json.loads('${{ steps.config.outputs.curseforge_java_versions }}')
          environments = json.loads('${{ steps.config.outputs.curseforge_environments }}')
          
          game_ids = [v['id'] for v in versions if v['name'] in game_versions]
          loader_ids = [v['id'] for v in versions if v['name'] in [l.capitalize() for l in loaders]]
          java_ids = [v['id'] for v in versions if v['name'] in java_versions]
          env_names = [e.capitalize() for e in environments]
          env_ids = [v['id'] for v in versions if v['name'] in env_names]
          
          all_ids = game_ids + loader_ids + java_ids
          all_ids = game_ids + loader_ids + java_ids + env_ids
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"ids={json.dumps(all_ids)}\n")
              f.write(f"game_ids={json.dumps(game_ids)}\n")
              f.write(f"env_ids={json.dumps(env_ids)}\n")
          EOF

      - name: Upload to Modrinth (Datapack)
        if: steps.changeset.outputs.found == 'true' && steps.config.outputs.modrinth_enabled == 'true'
        run: |
          FILENAME="${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.zip"
          
          DATA=$(jq -n \
            --arg pid "${{ steps.config.outputs.modrinth_project_id }}" \
            --arg name "v${{ steps.version.outputs.version }} (Datapack)" \
            --arg ver "${{ steps.version.outputs.version }}" \
            --arg type "${{ steps.parse.outputs.version_type }}" \
            --arg log "${{ steps.parse.outputs.changelog }}" \
            --arg gv "${{ steps.game_versions.outputs.csv }}" \
            '{project_id:$pid, name:$name, version_number:$ver, changelog:$log, version_type:$type, game_versions:($gv|split(",")), loaders:["datapack"], dependencies:[], file_parts:["file"], primary_file:"file"}')
          
          curl -sS -o resp.json -w "%{http_code}" \
            -X POST "https://api.modrinth.com/v2/version" \
            -H "Authorization: ${{ secrets.MODRINTH_TOKEN }}" \
            -H "User-Agent: ${{ github.repository }}" \
            -F "data=${DATA};type=application/json" \
            -F "file=@dist/${FILENAME};filename=${FILENAME}" | tee code.txt
          
          cat resp.json | jq .
          [ $(cat code.txt) -ge 200 ] && [ $(cat code.txt) -lt 300 ] || exit 1

      - name: Upload to Modrinth (Mod)
        if: steps.changeset.outputs.found == 'true' && steps.config.outputs.modrinth_enabled == 'true' && steps.config.outputs.package_as_mod_enabled == 'true'
        run: |
          FILENAME="${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.jar"
          
          DATA=$(jq -n \
            --arg pid "${{ steps.config.outputs.modrinth_project_id }}" \
            --arg name "v${{ steps.version.outputs.version }} (Mod)" \
            --arg ver "${{ steps.version.outputs.version }}" \
            --arg type "${{ steps.parse.outputs.version_type }}" \
            --arg log "${{ steps.parse.outputs.changelog }}" \
            --arg gv "${{ steps.game_versions.outputs.csv }}" \
            --arg ld "${{ steps.loaders.outputs.csv }}" \
            '{project_id:$pid, name:$name, version_number:$ver, changelog:$log, version_type:$type, game_versions:($gv|split(",")), loaders:($ld|split(",")), dependencies:[], file_parts:["file"], primary_file:"file"}')
          
          curl -sS -o resp.json -w "%{http_code}" \
            -X POST "https://api.modrinth.com/v2/version" \
            -H "Authorization: ${{ secrets.MODRINTH_TOKEN }}" \
            -H "User-Agent: ${{ github.repository }}" \
            -F "data=${DATA};type=application/json" \
            -F "file=@dist/${FILENAME};filename=${FILENAME}" | tee code.txt
          
          cat resp.json | jq .
          [ $(cat code.txt) -ge 200 ] && [ $(cat code.txt) -lt 300 ] || exit 1

      - name: Upload to CurseForge (Datapack)
        if: steps.changeset.outputs.found == 'true' && steps.config.outputs.curseforge_datapack_enabled == 'true'
        run: |
          FILENAME="${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.zip"
          
          DATA=$(jq -n \
            --arg name "v${{ steps.version.outputs.version }}" \
            --arg log "${{ steps.parse.outputs.changelog }}" \
            --arg type "${{ steps.parse.outputs.version_type }}" \
            --argjson ids '${{ steps.cf_versions.outputs.game_ids }}' \
            '{displayName:$name, changelog:$log, changelogType:"markdown", releaseType:$type, gameVersions:$ids}')
          
          curl -sS -o resp.json -w "%{http_code}" \
            -X POST "https://minecraft.curseforge.com/api/projects/${{ steps.config.outputs.curseforge_datapack_id }}/upload-file" \
            -H "X-Api-Token: ${{ secrets.CURSEFORGE_TOKEN }}" \
            -H "User-Agent: ${{ github.repository }}" \
            -F "metadata=${DATA};type=application/json" \
            -F "file=@dist/${FILENAME}" | tee code.txt
          
          cat resp.json | jq .
          [ $(cat code.txt) -ge 200 ] && [ $(cat code.txt) -lt 300 ] || exit 1

      - name: Upload to CurseForge (Mod)
        if: steps.changeset.outputs.found == 'true' && steps.config.outputs.curseforge_mod_enabled == 'true'
        run: |
          FILENAME="${{ steps.config.outputs.package_as_mod_id }}-${{ steps.version.outputs.version }}.jar"
          
          DATA=$(jq -n \
            --arg name "v${{ steps.version.outputs.version }}" \
            --arg log "${{ steps.parse.outputs.changelog }}" \
            --arg type "${{ steps.parse.outputs.version_type }}" \
            --argjson ids '${{ steps.cf_versions.outputs.ids }}' \
            '{displayName:$name, changelog:$log, changelogType:"markdown", releaseType:$type, gameVersions:$ids}')
          
          curl -sS -o resp.json -w "%{http_code}" \
            -X POST "https://minecraft.curseforge.com/api/projects/${{ steps.config.outputs.curseforge_mod_id }}/upload-file" \
            -H "X-Api-Token: ${{ secrets.CURSEFORGE_TOKEN }}" \
            -H "User-Agent: ${{ github.repository }}" \
            -F "metadata=${DATA};type=application/json" \
            -F "file=@dist/${FILENAME}" | tee code.txt
          
          cat resp.json | jq .
          [ $(cat code.txt) -ge 200 ] && [ $(cat code.txt) -lt 300 ] || exit 1

      - name: Update config
        if: steps.changeset.outputs.found == 'true'
        run: |
          python - <<'EOF'
          import yaml
          
          with open('deploy.yaml', 'r') as f:
              config = yaml.safe_load(f)
          
          config['project']['version']['major'] = int("${{ steps.version.outputs.major }}")
          config['project']['version']['minor'] = int("${{ steps.version.outputs.minor }}")
          config['project']['version']['patch'] = int("${{ steps.version.outputs.patch }}")
          
          with open('deploy.yaml', 'w') as f:
              yaml.dump(config, f, default_flow_style=False, sort_keys=False)
          EOF

      - name: Commit
        if: steps.changeset.outputs.found == 'true'
        run: |
          rm ${{ steps.changeset.outputs.file }}
          rm -f .changeset/*.md
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add deploy.yaml .changeset
          git commit -m "chore: release v${{ steps.version.outputs.version }}"
          git push
